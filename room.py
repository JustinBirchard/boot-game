#room.py
"""Class Room for player interactions within rooms."""

import time
import p_func
import random
from pathlib import Path

# Path objects that point to folders that contain related .txt files
Path_art_txt = Path('.').joinpath('text', 'art_txt') 
Path_misc_txt = Path('.').joinpath('text', 'misc_txt') 
Path_npc_txt = Path('.').joinpath('text', 'npc_txt')
Path_room_txt = Path('.').joinpath('text', 'room_txt')

class Room:
    """Class Room for player interactions within rooms.

        When constructing Room object, self.choices must be a list of strings in the following order:
        self.choices[0] thru [3]: Do not define during Room construction. These strings are default generated by self.choices definition. 
        self.choices[4]: 'Talk to NPC' (OPTIONAL) -- If not defined during Room construction default is None.
        self.choices[4] or [5]: 'Use Object' (OPTIONAL) -- If not defined during Room construction default is None.
                                'Use Object' Will be [4] option if self.npcs==None , else [5] if self.npcs is not None"""

    def __init__(self, quick_desc, choices, description_txt, doors, npcs=None, objects=None, decisions=[], examined='No', roomstate='active'):
        """Initializes each attribute of the Room."""
        self.quick_desc = quick_desc
        self.choices = ['Examine Room', 'Use Map', 'View Character Sheet', 'Use Door'] + choices
        self.description_txt = description_txt
        self.doors = doors
        self.npcs = npcs if npcs is not None else None
        self.objects = objects if objects is not None else None
        self._decisions = decisions
        self._examined = examined
        self._roomstate = roomstate
        
    @property
    def decisions(self):
        """return contents of the self._decisions list"""
        return self._decisions
    
    @property
    def clear_decisions(self):
        """clears contents of self._decisions list"""
        self._decisions.clear()

    @property
    def examined(self):
        """return contents of self._examined which tracks whether player has read description_txt"""
        return self._examined

    @property
    def roomstate(self):
        """return contents of self._roomstate which tracks whether player has triggered new Room state"""
        return self._roomstate

    @roomstate.setter
    def roomstate(self, state):
        """Allows contents of self._roomstate to be updated within boot.py"""

        if state == 'active':
            self._roomstate = state

        elif state == 'inactive':
            self._roomstate = state

        else:
            raise ValueError("roomstate must == 'active' or 'inactive'")
        
    def __str__(self):
        if self.npcs == None:
            number_of_npcs = 'It appears you are here alone.'
                
        elif len(self.npcs) > 1:
            number_of_npcs = 'There are several people in the room with you.'
            
        else:
            number_of_npcs = "There's one other person here with you."

        return ((f'You are in {self.quick_desc[0]}, it is {self.quick_desc[1]} \n') + 
                (f'You have access to {len(self.doors)} doors leading elsewhere. ' if len(self.doors) > 1 else 'You have access to one door leading elsewhere. \n') +
                (f'{number_of_npcs}'))

    def enter_room(self, player_choices=True):
        """Room description and player options for when player enters a Room.
           Default is to give the player choices. If only a description is wanted
           set player_choices=False.

           Args: player_choices (boolean) (optional): True or False to indicate whether player_choices() should be called
        """
        if self.npcs == None:
            number_of_npcs = 'It appears you are here alone.'
                
        elif len(self.npcs) > 1:
            number_of_npcs = 'There are several people in the room with you.'
            
        else:
            number_of_npcs = "There's one other person here with you."

        p_func.animate_strings([f'{(len(self.quick_desc[0]) + len(self.quick_desc[1]) + 23) * "_"}',
                                f'{(len(self.quick_desc[0]) + len(self.quick_desc[1]) + 23) * "_"}',
                                f'{(len(self.quick_desc[0]) + len(self.quick_desc[1]) + 23) * "_"}'], .003, .003)
        print(f'You are in {self.quick_desc[0]}, it is {self.quick_desc[1]}')
        p_func.animate_strings([f'You have access to {len(self.doors)} doors leading elsewhere. ' if len(self.doors) > 1 else 'You have access to one door leading elsewhere.',
                f'{number_of_npcs}\n'], .025, .2)
        input('<<<<<<---|--->>>>>>\n')

        if player_choices == True:
            self.player_choices()
            
    def player_choices(self):
        """Presents player with choices based on player's location in the game."""
                        
        global player_choice
        print('What do you choose?')
        if self.npcs is not None:
            for index, choice in zip([index for index in range(len(self.choices))], [choice for choice in self.choices]):
                print(f'{index + 1}: {choice}')
            print('')
            
            try:
                player_choice = int(input('Enter your choice: '))
                print('')
            
            except ValueError:
                print('You must enter the number that corresponds with your choice.')
                self.player_choices()
            
            else:       
                if player_choice > len(self.choices):
                    print('You must pick from the options above.')
                    self.player_choices()
                
                elif player_choice == 0:
                    print('You must pick from the options above')
                    self.player_choices()
     
                elif player_choice == 1:
                    self._decisions.append(player_choice)
                    self.room_description()
            
                elif player_choice == 2:
                    self.clear_decisions                    
                    self.use_map()
                
                elif player_choice == 3:
                    self.clear_decisions                    
                    self.view_character_sheet()
            
                elif player_choice == 4:
                    self._decisions.append(player_choice)
                    self.use_door()
            
                elif player_choice == 5:
                    self._decisions.append(player_choice)
                    self.talk_to_npc()
                
                elif player_choice == 6:
                    self._decisions.append(player_choice)
                    self.use_objects()
            
                else:
                    print('You must pick from the options above.')
                    
        else: # for if npcs==None 
            for index, choice in zip([index for index in range(len(self.choices))], [choice for choice in self.choices]):
                print(f'{index + 1}: {choice}')
            print('')
            
            try:
                player_choice = int(input('Enter your choice: '))
                print('')
            
            except ValueError:
                print('You must enter the number that corresponds with your choice.')
                self.player_choices()
            
            else:      
                if player_choice > len(self.choices):
                    print('You must pick from the options above.')
                    self.player_choices()
                
                elif player_choice == 0:
                    print('You must pick from the options above')
                    self.player_choices()
      
                elif player_choice == 1:
                    self._decisions.append(player_choice)
                    self.room_description()
            
                elif player_choice == 2:
                    self.clear_decisions                    
                    self.use_map()
                
                elif player_choice == 3:
                    self.clear_decisions                    
                    self.view_character_sheet()
            
                elif player_choice == 4:
                    self._decisions.append(player_choice)
                    self.use_door()
            
                elif player_choice == 5:
                    self._decisions.append(player_choice)
                    self.use_objects()
            
                else:
                    print('You must pick from the options above.')
       
    def room_description(self):
        space_counter = 0
        with open(f'{self.description_txt}', 'r') as description:
            for line in description:
                clean_line = line.rstrip() 
                time.sleep(.5)
    
                for character in clean_line:
                    if character == ' ':
                        space_counter += 1
                        time.sleep(.05)
                        print(character, end='', flush=True)

                        number_of_spaces = random.randrange(7, 13)

                        if space_counter >= number_of_spaces:
                            time.sleep(random.uniform(.12, .2))
                            space_counter = 0

                    elif character in ['.', '!', '?']:
                        print(character, end='', flush=True)
                        time.sleep(.6)

                    elif character == ',':
                        print(character, end='', flush=True)
                        time.sleep(.35)

                    else:
                        print(character, end='', flush=True)
                        time.sleep(random.uniform(.015, .035)) 
                print('')
            print('')

        input('<<<<<<---|--->>>>>>\n')
        self._examined = 'Yes'
        
    def use_map(self):
        p_func.animate_txt('the_whisp_art(75x75 FINAL)', 'art', .0001, .005)
        p_func.animate_txt('map_of_the_whisp_with_key(FINAL)', 'art', .0001, .005)
        input('\n<<<<<<---|--->>>>>>\n')
        
    def view_character_sheet(self):
        p_func.print_csheet()
        print('')
        
    def use_door(self):
        """Presents player with choices based on what doors are available in the Room.
        Note- the clear_decisions attribute method must always be called in boot.py after using .player_choices()"""
        print('Which door would you like to use?')
        print('0: Stay where you are')
        for index, door in zip([index for index in range(len(self.doors))], [door for door in self.doors]):
            print(f'{index + 1}: Door to {door}')
        print('')

        try:
            player_choice = int(input('Enter your choice: '))

        except ValueError:
            print('You must enter the number that corresponds with your choice.')
            self.use_door()

        else:
            if player_choice > len(self.doors):
                print('You must pick from the options above.')
                self.use_door()
                
            elif player_choice == 0:
                print('')

            else:
                self._decisions.append(player_choice)
        
    def talk_to_npc(self):
        """Presents player with choices based on what NPCs are available in the Room.
        Note- the clear_decisions attribute method must always be called in boot.py after using .player_choices()"""
        print('Who would you like to speak with?')
        for index, npc in zip([index for index in range(len(self.npcs))], [npc for npc in self.npcs]):
            print(f'{index + 1}: {npc}')
        print('')

        try:
            player_choice = int(input('Enter your choice: '))
            print('')

        except ValueError:
            print('You must enter the number that corresponds with your choice.')
            self.talk_to_npc()

        else:
            if player_choice > len(self.npcs):
                print('You must pick from the options above.')
                self.talk_to_npc()
                
            elif player_choice == 0:
                print('You must pick from the options above')
                self.talk_to_npc()

            else:
                self._decisions.append(player_choice)
        
    def use_objects(self):
        """Presents player with choices based on what objects are available in the Room.
        Note- the clear_decisions attribute method must always be called in boot.py after using .player_choices()"""
        print('What would you like to use?')
        for index, objects in zip([index for index in range(len(self.objects))], [objects for objects in self.objects]):
            print(f'{index + 1}: {objects}')

        try:
            player_choice = int(input('Enter your choice: '))
            print('')

        except ValueError:
            print('You must enter the number that corresponds with your choice.')
            self.use_objects()

        else:
            if player_choice > len(self.objects):
                print('You must pick from the options above.')
                self.use_objects()
                
            elif player_choice == 0:
                print('You must pick from the options above')
                self.use_objects()

            else:
                self._decisions.append(player_choice)

    def add_or_remove_door(self, door, add_or_remove):
        """Add or remove a door from a room. 
           door should be one string
           add_or_remove should be 'add' or 'remove'
        """          
        if add_or_remove == 'add':
            self.doors.append(door)

        elif add_or_remove == 'remove':
            self.doors.remove(door)

    def add_or_remove_object(self, object, add_or_remove):
        """Add or remove an object from a room. 
           object should be one string
           add_or_remove should be 'add' or 'remove'
        """          
        if add_or_remove == 'add':

            if self.objects == None:
                self.objects = []
                self.objects.append(object)

            else:
                self.objects.append(object)

        elif add_or_remove == 'remove':
            self.objects.remove(object)

            if self.objects == []:
                self.objects = None

    def add_or_remove_choice(self, choice, add_or_remove):
        """Add or remove a player choice from a room. 
           choice should be one string
           add_or_remove should be 'add' or 'remove'
        """          
        if add_or_remove == 'add':
            self.choices.append(choice)

        elif add_or_remove == 'remove':
            self.choices.remove(choice)

    def add_or_remove_npc(self, npc, add_or_remove):
        """Add or remove an npc from a room. 
           choice should be one string
           add_or_remove should be 'add' or 'remove'
        """          
        if add_or_remove == 'add':

            if self.npcs == None:
                self.npcs = []
                self.npcs.append(npc)

            else:
                self.npcs.append(npc)

        elif add_or_remove == 'remove':
            self.npcs.remove(npc)

            if self.npcs == []:
                self.npcs = None